/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

void configureAllLEDS(){
	uint32_t* porta = (uint32_t*) 0x48000800;
	uint32_t* portb= (uint32_t*) 0x48000400;

	*porta &= ~(0x3 << 14); //clear
	*porta |= (0x1 << 14); //set

	//mode for pb7 are bits 15 and 14, pb 14 are 28 and 29
	*portb &= ~(0x3 << 14);
	*portb &= ~(0x3 << 28);

	*portb |= (0x1 << 14);
	*portb |= (0x1 << 28);

	//output type,offset 0x04
	*(porta + 1) &= ~(0x1 << 7);

	*(portb + 1) &= ~(0x1 << 7);
	*(portb + 1) &= ~(0x1 << 14);

	//output speed medium, offset 0x08
	*(porta + 2) &= ~(0x3 << 14); //clear
	*(porta + 2) |= (0x1 << 14); //set

	*(portb + 2) &= ~(0x3 << 14); //clear
	*(portb + 2) &= ~(0x3 << 28);

	*(portb + 2) |= (0x1 << 14); // set
	*(portb + 2) |= (0x1 << 28);

	//pull up/down offset 0x0c , just clear
	*(porta + 3) &= ~(0x3 << 14);
	*(portb + 3) &= ~(0x3 << 14);
	*(portb + 3) &= ~(0x3 << 28);
}

uint8_t currColor = 0;
void TIM4_IRQHandler(void) {
	uint32_t* isPending = (uint32_t*)(0x40000800 + 0x10);

	uint32_t* porta = (uint32_t*) 0x48000800;
	uint32_t* portb = (uint32_t*) 0x48000400;

	uint32_t* green = porta + 5;
	uint32_t* blue = portb + 5;
	uint32_t* red = portb + 5;

	//turn off
	*green &= ~(0x1 << 7);
	*blue &= ~(0x1 << 7);
	*red &= ~(0x1 << 14);

	if (*isPending & 0x1){ //currently a pending interrupt
		if (currColor == 0){
			*green |= (0x1 << 7);
		}
		else if (currColor == 2){
			*blue |= (0x1 << 7);
		} else{
			*red |= (0x1 << 14);
		}
		currColor = (currColor + 1) % 3;
	}
	*isPending &= ~(1 << 0);
}

int main(void)
{
	//enable clock for gpios
	volatile uint32_t* clock = (uint32_t*) (0x40021000 + 0x4C);
	*clock |= 0x6; // only turn on clock for gpio b, c

	configureAllLEDS();

	volatile uint32_t* RCC_APB1ENR1 = (uint32_t*)(0x40021000 + 0x58); //offset 0x58 = 88 / 4 = 22
	*RCC_APB1ENR1 |= (0x1 << 2);

    volatile uint32_t* RCC = (uint32_t*) 0x40021000;
    volatile uint32_t* RCC_CR = RCC;

    *RCC_CR |= (0x1 << 8); //config HSION

    while (((*RCC_CR >> 10) & 0x1) != 1){
    	//wait
    }

    volatile uint32_t* RCC_CFGR = RCC + 2; //offset is 0x08 8/4 = 2

    //set sw
    *RCC_CFGR &= ~(0x3);
    *RCC_CFGR |= (0x1);

    while (((*RCC_CFGR >> 2) & 0x3) != 0x1){ //bits 2-3th in CFGR says if H16SI is ready or not
        	//wait
    }

    //configure timer 4 stuff
    //tim4 in apb1 -> have to enable clock for apb1
    //base of tim4 is 0x4000 0800

    volatile uint32_t* TIM4 =  (uint32_t*)0x40000800;

    volatile uint32_t* TIM4_PSC = (uint32_t*)((uint32_t)TIM4 + 0x28); //ofset 0x28 = 40 / 4 = 10
    *TIM4_PSC = 15999;

    volatile uint32_t* TIM4_ARR = (uint32_t*)((uint32_t)TIM4 + 0x2C);
    *TIM4_ARR = 999;

    volatile uint32_t* TIM4_EGR = (uint32_t*)((uint32_t)TIM4 + 0x14);
    *TIM4_EGR |= 0x1;

    volatile uint32_t* TIM4_DIER = (uint32_t*)((uint32_t)TIM4 + 0x0C);
    *TIM4_DIER |= 0x1;

    volatile uint32_t* TIM4_CR1 = (uint32_t*)((uint32_t)TIM4);
    *TIM4_CR1 |= 1;

    //NVIC config
    volatile uint32_t* NVIC = (uint32_t*)0xE000E100;
    *NVIC |= (0x1 << 30);

	while(1){

	}
}
