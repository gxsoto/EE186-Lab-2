/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

void configureAllLEDS(){
	volatile uint32_t* porta = (uint32_t*) 0x48000800;
	volatile uint32_t* portb= (uint32_t*) 0x48000400;

	*porta &= ~(0x3 << 14); //clear
	*porta |= (0x1 << 14); //set

	//mode for pb7 are bits 15 and 14, pb 14 are 28 and 29
	*portb &= ~(0x3 << 14);
	*portb &= ~(0x3 << 28);

	*portb |= (0x1 << 14);
	*portb |= (0x1 << 28);

	//output type,offset 0x04
	*(porta + 1) &= ~(0x1 << 7);

	*(portb + 1) &= ~(0x1 << 7);
	*(portb + 1) &= ~(0x1 << 14);

	//output speed medium, offset 0x08
	*(porta + 2) &= ~(0x3 << 14); //clear
	*(porta + 2) |= (0x1 << 14); //set

	*(portb + 2) &= ~(0x3 << 14); //clear
	*(portb + 2) &= ~(0x3 << 28);

	*(portb + 2) |= (0x1 << 14); // set
	*(portb + 2) |= (0x1 << 28);

	//pull up/down offset 0x0c , just clear
	*(porta + 3) &= ~(0x3 << 14);
	*(portb + 3) &= ~(0x3 << 14);
	*(portb + 3) &= ~(0x3 << 28);
}


volatile uint8_t currColor = 0;
volatile uint8_t isPaused = 0;


void EXTI15_10_IRQHandler(void) {
	volatile uint32_t* pending = (uint32_t*) (0x40010400 + 0x14);
	if (*pending & (1 << 13)) {
		*pending = (1 << 13);
		isPaused = !isPaused;
	}
}


void TIM4_IRQHandler(void) {
	volatile uint32_t* isPending = (uint32_t*)(0x40000800 + 0x10);

	volatile uint32_t* porta = (uint32_t*) 0x48000800;
	volatile uint32_t* portb = (uint32_t*) 0x48000400;

	volatile uint32_t* green = porta + 5;
	volatile uint32_t* blue = portb + 5;
	volatile uint32_t* red = portb + 5;

	if(!isPaused){
		//only turn off and cycle when we have not hit the button
		*green &= ~(0x1 << 7);
		*blue &= ~(0x1 << 7);
		*red &= ~(0x1 << 14);
		if (*isPending & 0x1){
			if (currColor == 0){
				*green |= (0x1 << 7);
			}
			else if (currColor == 1){
				*blue |= (0x1 << 7);
			} else{
				*red |= (0x1 << 14);
			}
			currColor = (currColor + 1) % 3;
		}
		*isPending &= ~(1 << 0);
	}
}


int main(void)
{
	volatile uint32_t* clock = (uint32_t*) (0x40021000 + 0x4C);
	*clock |= 0x6; // only turn on clock for gpio b, c

	configureAllLEDS();

	volatile uint32_t* apb1enr = (uint32_t*)(0x40021000 + 0x58); //offset 0x58 = 88 / 4 = 22
	*apb1enr |= (0x1 << 2);

	volatile uint32_t* RCC = (uint32_t*) 0x40021000;
	volatile uint32_t* cr = RCC;

	*cr |= (0x1 << 8); //config HSION

	while (((*cr >> 10) & 0x1) != 1){
		//wait
	}

	volatile uint32_t* cfgr = RCC + 2; //offset is 0x08 8/4 = 2

	//set sw
	*cfgr |= (0x1);

	while (((*cfgr >> 2) & 0x3) != 0x1){ //bits 2-3th in CFGR says if H16SI is ready or not
			//wait
	}

	//configure timer 4 stuff
	//tim4 in apb1 -> have to enable clock for apb1
	//base of tim4 is 0x4000 0800

	volatile uint32_t* tim4 =  (uint32_t*)0x40000800;

	volatile uint32_t* psc = (uint32_t*)((uint32_t)tim4 + 0x28); //ofset 0x28 = 40 / 4 = 10
	*psc = 15999;

	volatile uint32_t* arr = (uint32_t*)((uint32_t)tim4 + 0x2C);
	*arr = 999;

	volatile uint32_t* egr = (uint32_t*)((uint32_t)tim4 + 0x14);
	*egr |= 0x1;

	volatile uint32_t* dier = (uint32_t*)((uint32_t)tim4 + 0x0C);
	*dier |= 0x1;

	volatile uint32_t* cr1 = (uint32_t*)((uint32_t)tim4);
	*cr1 |= 0x1;

	//NVIC config
	volatile uint32_t* nvic = (uint32_t*)0xE000E100;
	*nvic |= (0x1 << 30);


	// ======================= ABOVE: TIMER INTERRUPT SETUP FOR CYCLING (from part 3) ==================

	//======================== BELOW: BUTTON EXTERNAL INTERRUPT SETUP (from part 2)====================
	//configure syscfg
	volatile uint32_t* apb2Clock = (uint32_t*) (0x40021000 + 0x60);
	*apb2Clock |= 0x1;

	// wire the exti
	volatile uint32_t* sys = (uint32_t*) (0x40010000 + 0x14);
	*sys |= (0x2 << 4); //config exti13

	//mexti mask
	volatile uint32_t* extiMask = (uint32_t*) (0x40010400);
	*extiMask |= (0x1 << 13);

	//enable both
	volatile uint32_t* extiEnable = (uint32_t*) (0x40010400 + 0x08);
	*extiEnable |= (1 << 13);
	volatile uint32_t* extiDisable = (uint32_t*) (0x40010400 + 0x0C);
	*extiDisable |= (1 << 13);

	//nvic set up
	volatile uint32_t* setEnable = (uint32_t*) 0xE000E104; //iser 1 addr
	volatile uint32_t* priority = (uint32_t*) 0xE000E428; // higher priority than other interrupts

	*setEnable |= (1 << 8);
	*priority = (0x10 << 24);

	uint32_t* portc = (uint32_t*) 0x48000800;
	*portc &= ~(0x3 << 26);
	*(portc + 3) |= (0x2 << 26);
}
